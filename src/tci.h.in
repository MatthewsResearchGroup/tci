#ifndef _TCI_H_
#define _TCI_H_

#if defined(__MIC__)
#ifndef TCI_ARCH_MIC
#define TCI_ARCH_MIC 1
#endif
#elif defined(__ia64) || defined(__itanium__) || defined(_M_IA64)
#ifndef TCI_ARCH_IA64
#define TCI_ARCH_IA64 1
#endif
#elif defined(__x86_64__) || defined(_M_X64)
#ifndef TCI_ARCH_X64
#define TCI_ARCH_X64 1
#endif
#elif defined(__i386) || defined(_M_IX86)
#ifndef TCI_ARCH_X86
#define TCI_ARCH_X86 1
#endif
#elif defined(__aarch64__)
#ifndef TCI_ARCH_ARM64
#define TCI_ARCH_ARM64 1
#endif
#elif defined(__arm__) || defined(_M_ARM)
#ifndef TCI_ARCH_ARM32
#define TCI_ARCH_ARM32 1
#endif
#elif defined(__powerpc64__) || defined(__ppc64__) || defined(__PPC64__)
#ifndef TCI_ARCH_PPC64
#define TCI_ARCH_PPC64 1
#endif
#elif defined(__powerpc__) || defined(__ppc__) || defined(__PPC__)
#ifndef TCI_ARCH_PPC32
#define TCI_ARCH_PPC32 1
#endif
#elif defined(__bgq__)
#ifndef TCI_ARCH_BGQ
#define TCI_ARCH_BGQ 1
#endif
#elif defined(__sparc)
#ifndef TCI_ARCH_SPARC
#define TCI_ARCH_SPARC
#endif
#elif defined(__mips)
#ifndef TCI_ARCH_MIPS
#define TCI_ARCH_MIPS
#endif
#else
#error "Unknown architecture"
#endif

#define TCI_USE_ATOMIC_SPINLOCK  @USE_ATOMIC_SPINLOCK@
#define TCI_USE_OMP_LOCK         @USE_OMP_LOCK@
#define TCI_USE_OPENMP_THREADS   @USE_OPENMP_THREADS@
#define TCI_USE_OSX_SPINLOCK     @USE_OSX_SPINLOCK@
#define TCI_USE_PTHREADS_THREADS @USE_PTHREADS_THREADS@
#define TCI_USE_PTHREAD_BARRIER  @USE_PTHREAD_BARRIER@
#define TCI_USE_PTHREAD_MUTEX    @USE_PTHREAD_MUTEX@
#define TCI_USE_PTHREAD_SPINLOCK @USE_PTHREAD_SPINLOCK@
#define TCI_USE_SPIN_BARRIER     @USE_SPIN_BARRIER@

#define TCI_MIN(x,y) ((x)<=(y)?(x):(y))
#define TCI_MAX(x,y) ((x)>=(y)?(x):(y))

#include <stdint.h>
#include <errno.h>

#ifdef __cplusplus
#define TCI_INLINE inline
#else
#define TCI_INLINE static inline
#include <stdbool.h>
#endif

#if TCI_ARCH_MIC
#include <immintrin.h>
#endif

#if TCI_ARCH_X86 || TCI_ARCH_X64
#include <xmmintrin.h>
#endif

#if TCI_USE_OSX_SPINLOCK
#include <libkern/OSAtomic.h>
#endif

#if TCI_USE_PTHREAD_SPINLOCK || \
    TCI_USE_PTHREAD_MUTEX || \
    TCI_USE_PTHREAD_BARRIER
#include <pthread.h>
#endif

#if TCI_USE_OMP_LOCK
#include <omp.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if TCI_ARCH_MIC

TCI_INLINE void tci_yield()
{
    _mm_delay(32);
}

#elif TCI_ARCH_X86 || TCI_ARCH_X64

TCI_INLINE void tci_yield()
{
    //_mm_pause();
    __asm__ __volatile__ ("pause");
}

#else

TCI_INLINE void tci_yield() {}

#endif

#if TCI_USE_OSX_SPINLOCK

typedef OSSpinLock tci_mutex_t;

#elif TCI_USE_PTHREAD_SPINLOCK

typedef pthread_spinlock_t tci_mutex_t;

#elif TCI_USE_ATOMIC_SPINLOCK

typedef int tci_mutex_t;

#elif TCI_USE_PTHREAD_MUTEX

typedef omp_lock_t tci_mutex_t;

#endif

int tci_mutex_init(tci_mutex_t* mutex);

int tci_mutex_destroy(tci_mutex_t* mutex);

int tci_mutex_lock(tci_mutex_t* mutex);

int tci_mutex_trylock(tci_mutex_t* mutex);

int tci_mutex_unlock(tci_mutex_t* mutex);

#if TCI_USE_PTHREAD_BARRIER

typedef struct
{
    tci_barrier_node_t* parent;
    pthread_barrier_t barrier;
} tci_barrier_node_t;

#elif TCI_USE_SPIN_BARRIER

typedef struct tci_barrier_node_s
{
    struct tci_barrier_node_s* parent;
    int nchildren;
    volatile int step;
    volatile int nwaiting;
} tci_barrier_node_t;

#endif

typedef struct
{
    union
    {
        tci_barrier_node_t* array;
        tci_barrier_node_t single;
    } barrier;
    int nthread;
    int group_size;
    bool is_tree;
} tci_barrier_t;

int tci_barrier_init(tci_barrier_t* barrier, int nthread, int group_size);

int tci_barrier_destroy(tci_barrier_t* barrier);

int tci_barrier_wait(tci_barrier_t* barrier, int tid);

typedef struct
{
    tci_barrier_t barrier;
    void* buffer;
    volatile int refcount;
} tci_context_t;

int tci_context_init(tci_context_t** context, int nthread, int group_size);

int tci_context_attach(tci_context_t* context);

int tci_context_detach(tci_context_t* context);

int tci_context_barrier(tci_context_t* context, int tid);

int tci_context_send(tci_context_t* context, int tid, void* object);

int tci_context_send_nowait(tci_context_t* context, int tid, void* object);

int tci_context_receive(tci_context_t* context, int tid, void** object);

int tci_context_receive_nowait(tci_context_t* context, int tid, void** object);

typedef struct
{
    tci_context_t* context;
    int nthread;
    int tid;
    int ngang;
    int gid;
} tci_comm_t;

typedef enum
{
    TCI_EVENLY         = (1<<1),
    TCI_CYCLIC         = (2<<1),
    TCI_BLOCK_CYCLIC   = (3<<1),
    TCI_BLOCKED        = (4<<1),
    TCI_NO_CONTEXT     =    0x1
} tci_gang_t;

extern const tci_comm_t* const tci_single;

int tci_comm_init_single(tci_comm_t* comm);

int tci_comm_init(tci_comm_t* comm, tci_context_t* context,
                  int nthread, int tid, int ngang, int gid);

int tci_comm_destroy(tci_comm_t* comm);

int tci_comm_is_master(const tci_comm_t* comm);

int tci_comm_barrier(tci_comm_t* comm);

int tci_comm_bcast(tci_comm_t* comm, void** object, int root);

int tci_comm_bcast_nowait(tci_comm_t* comm, void** object, int root);

int tci_comm_gang(tci_comm_t* parent, tci_comm_t* child,
                  int type, int n, int bs);

void tci_comm_distribute_over_gangs(tci_comm_t* comm, int64_t range,
                                    int64_t granularity, int64_t* first,
                                    int64_t* last, int64_t* max);

void tci_comm_distribute_over_threads(tci_comm_t* comm, int64_t range,
                                     int64_t granularity, int64_t* first,
                                     int64_t* last, int64_t* max);

void tci_comm_distribute_over_gangs_2d(tci_comm_t* comm, int64_t range_m,
                                       int64_t range_n, int64_t granularity_m,
                                       int64_t granularity_n, int64_t* first_m,
                                       int64_t* last_m, int64_t* max_m,
                                       int64_t* first_n, int64_t* last_n,
                                       int64_t* max_n);

void tci_comm_distribute_over_threads_2d(tci_comm_t* comm, int64_t range_m,
                                         int64_t range_n, int64_t granularity_m,
                                         int64_t granularity_n, int64_t* first_m,
                                         int64_t* last_m, int64_t* max_m,
                                         int64_t* first_n, int64_t* last_n,
                                         int64_t* max_n);

typedef void (*tci_thread_func_t)(tci_comm_t*, void*);

int tci_parallelize(tci_thread_func_t func, void* payload, int nthread, int arity);

typedef struct
{
    int n;
    int sqrt_n;
    int f;
} tci_prime_factors_t;

void tci_prime_factorization(int n, tci_prime_factors_t* factors);

int tci_next_prime_factor(tci_prime_factors_t* factors);

void tci_partition_2x2(int nthread, int64_t work1, int64_t work2, int* nt1, int* nt2);

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus

#include <system_error>
#include <tuple>
#include <utility>

namespace tci
{

class mutex
{
    public:
        mutex()
        {
            int ret = tci_mutex_init(&_lock);
            if (ret != 0) throw std::system_error(ret, std::system_category());
        }

        ~mutex() noexcept(false)
        {
            int ret = tci_mutex_destroy(&_lock);
            if (ret != 0) throw std::system_error(ret, std::system_category());
        }

        mutex(const mutex&) = delete;

        mutex(mutex&&) = default;

        mutex& operator=(const mutex&) = delete;

        mutex& operator=(mutex&&) = default;

        void lock()
        {
            int ret = tci_mutex_lock(&_lock);
            if (ret != 0) throw std::system_error(ret, std::system_category());
        }

        bool try_lock()
        {
            int ret = tci_mutex_trylock(&_lock);
            if (ret == EBUSY) return false;
            if (ret != 0) throw std::system_error(ret, std::system_category());
            return true;
        }

        void unlock()
        {
            int ret = tci_mutex_unlock(&_lock);
            if (ret != 0) throw std::system_error(ret, std::system_category());
        }
        
        operator tci_mutex_t*() { return &_lock; }
        
        operator const tci_mutex_t*() const { return &_lock; }

    protected:
        tci_mutex_t _lock;
};

class barrier
{
    public:
        barrier(int nthread, int group_size=0)
        {
            int ret = tci_barrier_init(&_barrier, nthread, group_size);
            if (ret != 0) throw std::system_error(ret, std::system_category());
        }

        ~barrier() noexcept(false)
        {
            int ret = tci_barrier_destroy(&_barrier);
            if (ret != 0) throw std::system_error(ret, std::system_category());
        }

        barrier(const barrier&) = delete;

        barrier(barrier&) = default;

        barrier& operator=(const barrier&) = delete;

        barrier& operator=(barrier&) = default;

        void wait(int tid)
        {
            int ret = tci_barrier_wait(&_barrier, tid);
            if (ret != 0) throw std::system_error(ret, std::system_category());
        }

        int num_threads() const
        {
            return _barrier.nthread;
        }

        int group_size() const
        {
            return _barrier.group_size;
        }
        
        operator tci_barrier_t*() { return &_barrier; }
        
        operator const tci_barrier_t*() const { return &_barrier; }

    protected:
        tci_barrier_t _barrier;
};

class communicator
{
    public:
        communicator()
        {
            tci_comm_init_single(*this);
        }

        ~communicator()
        {
            tci_comm_destroy(*this);
        }

        communicator(const communicator&) = delete;

        communicator(communicator&& other)
        : _comm(other._comm)
        {
            other._comm.context = nullptr;
        }

        communicator& operator=(const communicator&) = delete;

        communicator& operator=(communicator&& other)
        {
            std::swap(_comm, other._comm);
            return *this;
        }

        bool master() const
        {
            return tci_comm_is_master(*this);
        }

        void barrier() const
        {
            int ret = tci_comm_barrier(*this);
            if (ret != 0) throw std::system_error(ret, std::system_category());
        }

        int num_threads() const
        {
            return _comm.nthread;
        }

        int thread_num() const
        {
            return _comm.tid;
        }

        int num_gangs() const
        {
            return _comm.ngang;
        }

        int gang_num() const
        {
            return _comm.gid;
        }

        template <typename T>
        void broadcast(T*& object, int root=0) const
        {
            tci_comm_bcast(*this, (void**)&object, root);
        }

        template <typename T>
        void broadcast_nowait(T*& object, int root=0) const
        {
            tci_comm_bcast_nowait(*this, (void**)&object, root);
        }

        communicator gang(int type, int n, int bs=0) const
        {
            communicator child;
            int ret = tci_comm_gang(*this, &child._comm, type, n, bs);
            if (ret != 0) throw std::system_error(ret, std::system_category());
            return child;
        }

        std::tuple<int64_t,int64_t,int64_t>
        distribute_over_gangs(int64_t range, int64_t granularity=1) const
        {
            int64_t first, last, max;
            tci_comm_distribute_over_gangs(*this, range, granularity,
                                           &first, &last, &max);
            return std::make_tuple(first, last, max);
        }

        std::tuple<int64_t,int64_t,int64_t>
        distribute_over_threads(int64_t range, int64_t granularity=1) const
        {
            int64_t first, last, max;
            tci_comm_distribute_over_threads(*this, range, granularity,
                                             &first, &last, &max);
            return std::make_tuple(first, last, max);
        }

        std::tuple<int64_t,int64_t,int64_t,int64_t,int64_t,int64_t>
        distribute_over_gangs_2d(int64_t range_m, int64_t range_n,
                                 int64_t granularity_m=1, int64_t granularity_n=1) const
        {
            int64_t first_m, last_m, max_m, first_n, last_n, max_n;
            tci_comm_distribute_over_gangs_2d(*this, range_m, range_n,
                                              granularity_m, granularity_n,
                                              &first_m, &last_m, &max_m,
                                              &first_n, &last_n, &max_n);
            return std::make_tuple(first_m, last_m, max_m, first_n, last_n, max_n);
        }

        std::tuple<int64_t,int64_t,int64_t,int64_t,int64_t,int64_t>
        distribute_over_threads_2d(int64_t range_m, int64_t range_n,
                                   int64_t granularity_m=1, int64_t granularity_n=1) const
        {
            int64_t first_m, last_m, max_m, first_n, last_n, max_n;
            tci_comm_distribute_over_threads_2d(*this, range_m, range_n,
                                                granularity_m, granularity_n,
                                                &first_m, &last_m, &max_m,
                                                &first_n, &last_n, &max_n);
            return std::make_tuple(first_m, last_m, max_m, first_n, last_n, max_n);
        }
        
        operator tci_comm_t*() const { return const_cast<tci_comm_t*>(&_comm); }

    protected:
        tci_comm_t _comm;
};

namespace detail
{

template <typename Body>
void body_wrapper(tci_comm_t* comm, void* data)
{
    Body& body = *static_cast<Body*>(data);
    body(*reinterpret_cast<communicator*>(comm));
}

}

template <typename Body>
void parallelize(Body&& body, int nthread, int arity=0)
{
    // The first line is necessary to trigger template instantiation
    tci_thread_func_t func = detail::body_wrapper<Body>;
    tci_parallelize(func, const_cast<void*>(static_cast<const void*>(&body)),
                    nthread, arity);
}

class prime_factorization
{
    public:
        prime_factorization(int n)
        {
            tci_prime_factorization(n, &_factors);
        }

        int next()
        {
            return tci_next_prime_factor(&_factors);
        }

    protected:
        tci_prime_factors_t _factors;
};

inline std::pair<int,int>
partition_2x2(int nthreads, int64_t work1, int64_t work2)
{
    int nt1, nt2;
    tci_partition_2x2(nthreads, work1, work2, &nt1, &nt2);
    return std::make_pair(nt1, nt2);
}

}

#endif

#endif
